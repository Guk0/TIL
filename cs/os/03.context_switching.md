
# 컨텍스트 스위칭
### 프로세스와 컨텍스트 스위칭
- 프로세스(process)는 일반적으로 어떻게 구성되어 있을까?
  - text(CODE): 코드
  - data : 변수/초기화된 데이터
  - stack: 임시 데이터(함수 호출, 로컬 변수 등) - stack frame
    - 위에서 부터 차례대로 **return address부터 작성**하여 지역변수 등이 기록됨
    - 함수 호출이 끝나 비워줄때는 지역변수 부터 날리고 마지막에 return address를 지워주면서 return address에 해당하는 코드로 가 다음 코드를 실행하게 됨.
  - heap: 코드에서 동적으로 만들어지는 데이터(메모리)
    - 처음에 heap영역의 가장 아래부터 위로 쌓임. 지워지는건 순서 상관없이 지워짐.
- PC(Program Counter) + SP(Stack Pointer)
  - PC 0번부터 실행. 0000h.
  - PC(Program Counter): TEXT(CODE)가 선언된 메모리 주소에서 SP의 return address에 맞춰서 해당 주소값으로 프로그램 코드를 진행하게 하는 것. 정확히는 중앙 처리 장치 내부의 레지스터 중 하나로 **다음에 실행될 명령어의 주소를 가지고 있어** 실행할 기계어 코드의 위치를 지정한다. 명령어 포인터라고 표현하기도 한다.
  - SP(Stack Pointer) : stack frame 메모리 주소를 가리키는 포인터, 레지스터의 메모리 공간에는 stack의 최상단 메모리 주소를 갖고있으며 stack pointer는 해당 메모리 주소를 가져다 쓴다. STACK에서 새로운 항목이 추가되거나 데이터가 제거되면 PUSH와 POP을 통해 주소값이 증가하거나 감소한다.
- PCB(Process Control Block)
  Process Status(5가지 상태) / Program counter(실행 횟수)

<br>


### Heap이란?
```c
#include <studio.h>
#include <stdlib.h>

int main()
{
	int *data;
	data = (int *) malloc(sizeof(int)); //32 bit
	*data = 1;
	printf("%d\n", *data);

	return 0;
}
```
- malloc() ↔ free() 메모리 해제
- 정적으로 생성되는 컴파일러 안에서는 동적으로 메모리가 얼마나 할당될지 모르기 떄문에 malloc을 사용하여 heap에 할당한다.

<br>


### data 영역
- BSS
  - 초기화되지 않은 전역 변수 `int global data1;`
- DATA
  - 초기 값이 있는 전역 변수 `int global data1 = 1;`

<br><br>


## 프로세스와 컨텍스트 스위칭
> PC(Program Counter) + SP(Stack Pointer)  
> 컨텍스트 스위칭이 일어나면 PCB에서 이전 프로세스에 대한 정보를 저장함.  
> Process A와 B가 있을 때 A → B 컨텍스트 스위치 시 A의 프로세스 상태정보를 PCB에 저장함. B → A 로 다시 전환 시 PCB를 확인하여 작업을 이어나감.


### PCB
> PC, SP는 PCB(Process Controll Block)에 저장.
- 프로세스가 실행중인 상태를 캡쳐/구조화하여 저장
- 저장 정보
    - process Id(PID)
    - Register 값(PC, SP 등)
    - Scheduling Info(Process State)
    - Memory Info (메모리 사이즈 limit)

<br>


### 프로세스와 컨텍스트 스위칭
- Context Switching(문맥 교환)
    - CPU에 실행할 프로세스를 교체하는 기술
- 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서, **메인 메모리에 저장**
- 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB 정보(PC, SP)를 **CPU에 넣고 실행**
    - CPU PC/SP 레지스터에 업데이트 한다.
- 디스패치(dispatch) : ready 상태의 프로세스를 running 상태로 바꾸는 것
- 굉장히 빈번하게 일어나기 때문에 이 시간을 줄여야 함.
    - C언어가 아니라 어셈블리어로 작성되는 경우가 많음.
- 레코드 판 가운데 핀을 놓는 느낌. 노래를 바꾸려면 핀을 위아래로 움직여야 함.

<br>


### 컴파일러
- 초기 컴퓨터 프로그램들은 어셈블리어로 작성
    - 서로 다른 CPU 아키텍쳐가 등장할 때마다 매번 똑같은 프로그램 작성.
    - 어셈블리어로는 프로그램 작성 속도가 매우 떨어짐 → 이식성이 매우 떨어짐.
    - 다만 속도는 매우 빠름.
    - 그래서 전환 시간을 줄여야 하는 컨택스트 스위칭에서는 어셈블리어로 작성하였다.
- 컴파일러의 등장
    - CPU 아키텍처에 따라서는 컴파일러 프로그램만 만들면 됨. 기존 코드는 재작성할 필요 없음.
    - 그러나 어셈블리어로 작성한 코드보다는 속도가 떨어질 수 있음.

<br>


### 프로세스간 커뮤니케이션(InterProcess Communication) - IPC 기법
> 프로세스들이 서로의 공간을 쉽게 접근할 수 있다면 위험함. 그래서 프로세스는 다른 프로세스의 공간을 원칙적으로 접근할 수 없다.
- IPC : 프로세스 간 통신 방법을 제공
- 프로세스 간 통신이 필요한 이유?
    - 성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행
    - 이 때 프로세스간 상태 확인 및 데이터 송수신 필요
    - fork() 시스템 콜을 사용하여 여러 프로세스를 동시에 실행할 수 있다.
        - fork() 함수로 프로세스 자신을 복사하여 새로운 프로세스를 만들 수 있음.(parent, child process)
        - 병렬 처리를 위해 fork() 함수 사용.
        - ex) 1부터 10000까지 더하기.
            - fork 함수로 프로세스 10개 복사하여 각각 1~1000, 1001~2000... 천단위로 작업 실행
            - 여기서 각  프로세스의 작업결과를 수집해야하므로 프로세스간 통신 필요.
        - ex) 웹서버
            - 새로운 사용자 요청이 올 때마다 fork 함수로 새로운 프로세스 만들고, 각 사용자 요청에 즉시 대응
            - 하지만 상태 값을 공유할 필요가 있어 위 요청에 대한 프로세스간 통신이 필요함.
- file(저장매체)을 사용하면 실시간으로 직접 원하는 프로세스에 데이터 전달이 어려움.
    
<br>
 

### 운영체제의 프로세스 공간
- 프로세스는 0 ~ 4GB의 해당하는 주소값을 가짐.
    - 이는 가상 주소. 실제 물리 메모리에 있는 공간과는 다른 개념.
    - 내부적으로 가상주소를 물리주소로 바꾸는 기능이 있음.
- 3~4GB 운영체제 코드가 들어가는 공간(kernal 영역)
- 0~3GB 사용자 입력 코드가 들어가는 공간
- 실제 물리주소의 커널공간(3~4GB)은 프로세스간에 공유가 가능하다

<br>


### 다양한 IPC 기법
- file 사용
- **커널영역 사용 기법(대부분의 IPC는 커널공간을 사용한다. 프로세스는 커널공간을 공유하고 있기 때문)**
    - message Queue
    - Shared Memory
    - Pipe
    - Signal
    - Semaphore
    - Socket

<br>


### 메시지 큐
- FIFO 사용. 먼저 넣은 데이터가 먼저 읽힌다.
- 프로세스 간의 메시지 전달.
- 부모/자식이 아니라 어느 프로세스간에라도 데이터 송수신이 가능
- vs Pipe
    - 부모/자식 프로세스 간 not or only
    - 양방향 가능 or 단방향만 가능

<br>

### IPC기법과 커널모드
- 메모리 공간도 kernel/user로 구분된다.

<br>

### 공유 메모리(shared memory)
- 노골적으로 kernel space에 메모리 공간을 만들고, 해당 공간을 변수처럼 쓰는 방식.
- 메세지 큐처럼 FIFO 방식이 아니라 핻아 메모리 주소를 마치 변수처럼 접근하는 방식
- 공유메모리 key를 가지고 여러 프로세스가 접근 가능.

<br>

## Signal
> signal과 socket은 IPC기법을 위해 만든 개념은 아니다!
- 유닉스에서 30년이상 사용된 전통적인 기법
- 커널 또는 프로세스에서 다른 프로세스에 어떤 **이벤트(시그널)**가 발생되었는지를 알려주는 기법
- 프로세스 관련 코드에 관련 시그널 핸들러를 등록해서, 해당 시그널 처리 실행
    - 시그널 무시
    - 시그널 블록(블록을 푸는 순간, 프로세스에 해당 시그널 전달)
    - 등록된 시그널 핸들러로 특정 동작 수행
    - 등록된 시그널 핸들러가 없다면, 커널에서 기본 동작 수행.
- 주요 시그널
    - kill -list로 시그널 확인가능.
    - SIGKILL : 프로세스를 죽여라(슈퍼관리자가 사용하는 시그널로 프로세스는 어떤 경우든 죽도록 되어 있음)
    - SIGALARM: 알람을 발생한다.
    - SIGSTP: 프로세스를 멈춰라(Ctrl + z)
    - SIGCONT: 멈춰진 프로세스를 실행하라
    - SIGINT: 프로세스에 인터럽트를 보내서 프로세스를 죽여라(Ctrl + c)
    - SIGSEGV: 프로세스가 다른 메모리 영역을 침범했다.
    - SIGUSR1, SIGUSR2 : 사용자 정의 시그널.

<br>

### 시그널과 프로세스
- PCB에 해당 프로세스가 블록 또는 처리해야하는 시그널 관련 정보 관리
- 사용자 모드에서 커널모드로 전환 후 다시 사용자 모드로 돌아오기 전 해당 프로세스의 PCB를 확인하여 PCB의 시그널 자료구조를 확인하여 어떤 시그널이 처리가 필요하다면 해당 처리가 필요한 커널함수를 실행한 후 사용자 모드로 돌아감.

<br>

## Socket
- 소켓은 네트워크 통신을 위한 기술
- 기본적으로는 클라이언트와 서버 등 두개의 다른 컴퓨터간의 네트워크 기반 통신을 위한 기술.
- 소켓을 하나의 컴퓨터 안에서 두 개의 프로세스 간에 통신 기법으로 사용 가능.