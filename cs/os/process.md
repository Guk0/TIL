# 프로세스

## 프로세스 스케쥴링
### 배치 처리 시스템
- 두가지의 프로그램을 순차적으로 등록.
- 큐와 같은 방식으로 동작(FIFO)

### 배치처리 시스템의 한계와 시분할 시스템/멀티 프로그래밍
- MP3 음악을 들으면서 문서 작성 → 배치처리 시스템에서는 이러한 작업 방식은 불가능(**동시성 문제**)
- 여러 사용자가 동시에 하나의 컴퓨터를 쓰려면 어떻게?(**다중 사용자 문제**)
- 위와 같은 이유로 멀티 프로그래밍/시분할 시스템이 등장


### 시분할 시스템
- **다중 사용자 지원**을 위해 컴퓨터 **응답 시간을 최소화**하는 시스템
- 시간 단위로 작업들을 쪼겜.

### 멀티태스킹
- 단일 CPU에서 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템. (단일 코어일 때)
- MP3 음악을 들으며 문서 작성
- 응용 프로그램을 잘게 쪼게서 실행 시키면 사용자가 인지하지 못할만큼의 딜레이가 있어도 사용자는 별로 크게 불편함을 느끼지 않는다. 동시에 실행되는 것처럼 보임.
- 10 ~ 20ms 단위로도 실행 응용 프로그램이 바뀜. 사용자에게는 동시에 실행되는 것처럼 보임.
- 시분할 시스템과 동일하지만 목적이 다름
  - **시분할 시스템** : **다중 사용자를 지원하는 것이 목적**이며, 다중 사용자를 지원하기 위해선 컴퓨터 응답 시간을 최소화 해야하는데 이에 적절한 시스템
  - **멀티태스킹** : 여러 **응용 프로그램의 병렬 실행**을 가능하게 하고 시간대비 CPU 사용률을 높이는 것이 목적. 단일 CPU에서 여러 응용프로그램이 동시에 실행되고 있는 것 처럼 보임.


### 멀티태스킹과 멀티 프로세싱
- 멀티 태스킹 : 단일 CPU.
- 멀티 프로세싱 : 다중 CPU.  **여러 CPU에 하나의 프로그램을 병렬로 실행**해서 실행속도를 극대화 시키는 시스템.

### 멀티 프로그래밍
- **최대한 CPU를 많이 활용하도록 하는 시스템**
    - 한 프로세스에서 I/O처리를 위해 block 되면 **그 시간동안 다른 프로세스가 실행되도록 해서** **CPU의 실행 효율을 극대화**시키는 방법.
    - 시간 대비 CPU활용도를 높이자.
    - 응용 프로그램은 짧은 시간 안에 실행 완료 시킬 수 있음.
    - 스케쥴링 알고리즘과 연관
- 응용 프로그램은 온전히 CPU를 쓰기 보다 **다른 작업을 중간에 필요로 하는 경우**가 많다.
    - 응용 프로그램이 실행되다가 파일을 읽는다.(저장매체에서 파일을 읽는 순간 응용 프로그램은 아무 작업도 할 수 없음. 파일을 읽어 변수에 담는다. )
    - 응용 프로그램이 실행되다가 프린팅을 한다.

### 프로세스(process)란?
- **실행 중인 프로그램**을 프로세스라고 함.
  - 프로세스 : 메모리에 올려져서 실행 중인 프로그램
  - 코드 이미지(바이너리): 실행 파일, 예) ELF format
- 프로세스라는 용어는 작업, task, job이라는 용어와 혼용


### 응용 프로그램 ≠ 프로세스
- 응용 프로그램은 여러 개의 프로세스로 이루어질 수 있음.
- 하나의 응용 프로그램은 여러 개의 프로세스(프로그램)가 상호작용을 하면서 실행될 수 있음.
- 간단한 C/C++ 프로그램을 만든다면 하나의 프로세스만 필요하겠지만
- 여러 프로그램을 만들어서 서로 통신하면서 프로그램을 작성할 수도 있음.(IPC 기법)

### 스케쥴러와 프로세스
- 스케쥴러 : 프로세스를 관리


<br/>

### RTOS & GPOS
- RealTime OS(RTOS) : 응용 프로그램 실시간 성능 보장을 목표로하는 OS
  - 정확하게 프로그램 시작, 완료 시간을 보장
  - Hardware RTOS, Software RTOS
- General Purpose OS(GPOS) :
  - 프로세스 실행 시간에 민감하지 않고, 일반적인 목적으로 사용되는 OS
  - windows, LINUX 등


## 스케쥴링 알고리즘
### FIFO 스케쥴러
- 프로세스가 저장매체를 읽는 다든지, 프린팅을 한다든지 하는 작업 없이 쭉 CPU를 처음부터 끝까지 사용한다.
- 가장 간단한 스케쥴러.
  - 1번, 2번, 3번 순으로 프로세스 요청이 들어왔을때 요청 순으로 순차적으로 실행.
  - 배치 처리 시스템과 유사.
  - FCFS(First Come First Served) 스케쥴러

### 최단 작업 우선(Shortest Job First) 스케쥴러
- 가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행시키는 스케쥴러 알고리즘.
- 실행 시간을 모두 알아야 처리가 가능함.

### 우선순위 기반 스케쥴러(Priority-Based 스케쥴러)
- 정적 우선순위
    - 프로세스마다 우선순위를 미리 지정.
- 동적 우선순위
    - 스케쥴러가 상황에 따라 우선순위를 동적으로 변경

### Round Robin 스케쥴러
- 시분할 시스템을 기본으로 함. 
- 시간 단위로 프로세스를 쪼게어 실행 후 일정 시간 뒤 다른 프로세스를 실행. 
- 기존 프로세스는 RR 준비 큐에 넣어 둠. 


### 프로세스 상태
- new : 프로세스가 만들어지는 과정
- **running state**
  - 현재 CPU에서 실행 상태
- **ready state**
  - CPU에서 실행 가능한 상태(실행 대기 상태)
- **block state**
  - 특정 이벤트 발생 대기 상태(ex. 프린팅이 다 되었다!)
  - 저장 매체 파일 읽기 요청 시 해당 프로세스는 블록 상태가 됨. 
  - 요청 완료시 이벤트 발생. 이 이벤트를 대기하는 상태가 block 상태.
- exit / ternimated
  - 처리 완료된 상태

### 프로세스 상태 간 관계
- running 상태에서 파일 읽기 → block 상태(1) - 특정 이벤트 대기 → 파일 읽기 완료(이벤트 발생) - ready 상태로 변경 → 스케쥴러에 의해 다시 running 상태로 변경


### 선점형과 비선점형 스케쥴러
- 선점형 스케쥴러(preemptive Scheduling)
  - 하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 차지할 수 있음.
  - 인터럽트 필요
- 비선점형 스케쥴러(Non-Preemptive Scheduling)
  - 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음.
  - 프로세스가 **자발적으로 blocking 상태**로 들어가거나 **실행이 끝났을  때**만 다른 프로세스로 교체 가능.
  - 실행시간이 긴 프로세스가 CPU를 점유할 경우 응답 시간이 길어질 수 있음.


### 스케쥴러 조합
- FIFO(FCFS), SJF, Priority-based는 어떤 프로세스를 실행시킬지에 대한 알고리즘(비 선점형 스케쥴러)
- Round Robin은 시분할 시스템을 위한 기본 알고리즘(선점형 스케쥴러)
  - 시분할 시스템도 선점형 스케쥴러.
- 최신의 알고리즘은 위 예를 복합적으로 적용하여 구현.

<br/>

## 인터럽트
### 인터럽트
- CPU가 프로그램을 실행하고 있을 때, **입출력 하드웨어 등의 장치(이벤트 발생)**나 또는 예외 상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술
- 어느 한 순간 CPU가 처리하는 명령은 하나이다. 다른 장치와 어떻게 커뮤니케이션을 할까?

### 인터럽트 필요 이유
- **선점형 스케쥴러 구현**
  - 프로세스 running 중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체하기 위해, 현재 프로세스 실행을 중단시킴.
    - 그러려면, 스케쥴러 코드가 실행이 돼서, 현 프로세스 실행을 중지시켜야 함.
- **IO Device와의 커뮤니케이션**
  - 저장매체에서 데이터 처리 완료시, 프로세스를 깨워야 함.(block state → ready state)
- **예외상황 핸들링**
  - CPU가 프로그램을 실행하고 있을때, 입출력 하드웨어 등의 장치나 또는 예외상황이 필요할 경우, CPU가 해당 처리를 할 수 있도록 CPU에 알려줘야 함.
  - 1 / 0 계산의 경우 값이 무한대기 때문에 다음 프로세스로 넘어갈 수 가 없음. 이런 프로세스를 kill해야 함.

### 인터럽트 처리 예
- CPU가 프로그램을 실행하고 있을 때,
  - 입출력 하드웨어 등의 장치 이슈 발생
    - 파일 처리가 끝났다는 것을 운영체제에 알려주기.
    - 운영체제는 해당 프로세스를 block state에서 실행 대기(ready)  상태로 프로세스 상태 변경하기
  - 또는 예외 상황이 발생
    - 0으로 나누는 계산이 발생하여 예외 발생을 운영체제에 알려주기
    - 운영체제가 해당 프로세스 실행 중지/에러 표시

### 인터럽트 종류
- **내부 인터럽트**
  - 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
    - 0으로 나눴을 때
    - 사용자 모드에서 허용되지 않은 명령 또는 공간 접근시
    - 계산 결과가 Overflow/underflow 날때(PL에서 데이터 타입이 정의하는 bit수를 초과할때)
      - overflow : 2^31 + 2^31 (양의 정수 초과)
      - underflow : (-2^31) + (-2^31) ( 음의 정수 초과)
  - 소프트웨어 인터럽트라고도 함
    
- **외부 인터럽트**
  - 주로 하드웨어에서 발생되는 이벤트(프로그램 외부)
    - 전원 이상
    - 기계 문제
    - 키보드 등 **IO** 관련 이벤트
    - **Timer 이벤트**
  - 하드웨어 인터럽트라고도 함.


### 시스템 콜 인터럽트
- 시스템 콜 실행을 위해서는 **강제로 코드에 인터럽트 명령을 넣어 CPU에게 실행**시켜야 한다.
- 시스템 콜 실제 코드
  - eax 레지스터에 시스템 콜 번호를 넣고,
  - ebx 레지스터에는 시스템 콜에 해당하는  인자값을 넣고,
  - 소프트웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨줌

```c
mob eax, 1 (시스템 콜번호)
mov ebx, 0 (인자) 
int 0x80   (int -> interrupt, 0x80 인터럽트 번호(시스템콜))
```

- 인터럽트 플로우
  - 시스템 콜 인터럽트 명령을 호출하면서 0x80값을 넘겨줌
  - CPU는 사용자 모드를 커널 모드로 바꿔줌
  - IDT(interrupt Descriptor Table)에서 0x80에 해당하는 주소(함수)를 찾아서 실행함
  - system_call()함수에서 eax로부터 시스템 콜 번호를 찾아 해당 번호에 맞는 시스템 콜 함수로 이동
  - 해당 시스템콜 함수 실행 후 다시 커널모드에서 사용자모드로 변경하고 다시 해당 프로세스 다음 코드 진행.

- 사용자 모드에서 커널모드로 수시로 이동함. 수많은 인터럽트가 존재.
- 시스템 콜을 위해서 사용자모드에서 커널모드로 변경되어야함
- I/O 혹은 하드웨어 접근은 시간을 많이 잡아먹으므로 빈번한 I/O 처리는 자제해야 한다.


### 인터럽트와 IDT
- 인터럽트는 미리 정의되어 각각 번호와 실행코드를 가리키는 주소가 기록되어 있음.
    - 어디에? IDT(Interrupt Descriptor Table)에 기록. 이벤트 번호, 실행코드 주소(함수)
    - 언제? 컴퓨터 부팅시 운영체제가 기록
    - 어떤 코드? 운영체제 내부 코드
- 다시 예를 보면
    - 항상 인터럽트 발생시 IDT를 확인
    - 시스템 콜 인터럽트 명령은 0x80번호가 미리 정의
    - 인터럽트 0x80에 해당하는 운영체제 코드는 system_call()이라는 함수
    - 즉 IDT에는 0x80 → system_call()와 같은 정보가 기록되어 있음.
- 리눅스의 예
    - 0~31 : 예외상황 인터럽트(일부는 정의되지 않은 상태로 남겨져 있음) - 내부(소프트웨어) 인터럽트
    - 32~47 : 하드웨어 인터럽트(주변장치 종류/갯수에 따라 변경 가능)
    - 128 : 시스템 콜(0x80)



### 인터럽트와 프로세스
1. 프로세스 실행 중 인터럽트 발생
2. 현 프로세스 실행 중단
3. 인터럽트 처리 함수 실행(운영체제)(IDT에서 해당하는 함수 실행 → 사용자 모드로 되돌아감)
4. 현 프로세스 재실행

<br/>

## 컨텍스트 스위칭
### 프로세스와 컨텍스트 스위칭
- 프로세스(process)는 일반적으로 어떻게 구성되어 있을까?
  - text(CODE): 코드
  - data : 변수/초기화된 데이터
  - stack: 임시 데이터(함수 호출, 로컬 변수 등) - stack frame
    - 위에서 부터 차례대로 **return address부터 작성**하여 지역변수 등이 기록됨
    - 함수 호출이 끝나 비워줄때는 지역변수 부터 날리고 마지막에 return address를 지워주면서 return address에 해당하는 코드로 가 다음 코드를 실행하게 됨.
  - heap: 코드에서 동적으로 만들어지는 데이터(메모리)
    - 처음에 heap영역의 가장 아래부터 위로 쌓임. 지워지는건 순서 상관없이 지워짐.
- PC(Program Counter) + SP(Stack Pointer)
  - PC 0번부터 실행. 0000h.
  - PC(Program Counter): TEXT(CODE)가 선언된 메모리 주소에서 SP의 return address에 맞춰서 해당 주소값으로 프로그램 코드를 진행하게 하는 것. 정확히는 중앙 처리 장치 내부의 레지스터 중 하나로 **다음에 실행될 명령어의 주소를 가지고 있어** 실행할 기계어 코드의 위치를 지정한다. 명령어 포인터라고 표현하기도 한다.
  - SP(Stack Pointer) : stack frame 메모리 주소를 가리키는 포인터, 레지스터의 메모리 공간에는 stack의 최상단 메모리 주소를 갖고있으며 stack pointer는 해당 메모리 주소를 가져다 쓴다. STACK에서 새로운 항목이 추가되거나 데이터가 제거되면 PUSH와 POP을 통해 주소값이 증가하거나 감소한다.
- PCB(Process Control Block)
  Process Status(5가지 상태) / Program counter(실행 횟수)


### Heap이란?
```c
#include <studio.h>
#include <stdlib.h>

int main()
{
	int *data;
	data = (int *) malloc(sizeof(int)); //32 bit
	*data = 1;
	printf("%d\n", *data);

	return 0;
}
```
- malloc() ↔ free() 메모리 해제
- 정적으로 생성되는 컴파일러 안에서는 동적으로 메모리가 얼마나 할당될지 모르기 떄문에 malloc을 사용하여 heap에 할당한다.


### data 영역
- BSS
  - 초기화되지 않은 전역 변수 `int global data1;`
- DATA
  - 초기 값이 있는 전역 변수 `int global data1 = 1;`