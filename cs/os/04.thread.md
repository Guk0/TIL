# Thread
## 스레드란?

- Light Weight Process라고도 함
- 프로세스
    - 프로세스 간에는 각 프로세스의 데이터 접근이 불가(IPC로 해결)
- 스레드
    - 하나의 프로세스에 여러개의 스레드 생성 가능
    - 스레드들은 동시에 실행 가능
    - 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능

- 각기 실행이 가능한 Stack 존재.
    - 프로세스 스택영역에서 각각의 실행역역을 가지는 함수라고 생각하면 됨.
    - 프로세스 안의 HEAP, BSS, DATA, CODE 영역 공유.

<br>

## 멀티 프로세싱과 쓰레드
- 멀티 태스킹과 멀티 프로세싱
    - 멀티 프로세싱은 쓰레드를 여러개 만들어서 구현할 수도 있음.
- 최근 CPU는 멀티코어를 가지므로 쓰레드를 여러개 만들어 멀티 코어 활용도를 높임.
- 싱글 코어 싱글 쓰레드 / 싱글 코어 멀티 쓰레드 /  멀티 코어 싱글 쓰레드 / 멀티 코어 멀티 스레드


<br>


## 쓰레드의 장점
- 사용자에 대한 응답성 향상
    - 특정 작업을 진행하는 스레드와 사용자와의 커뮤니케이션을 하는 스레드로 나누어 작업 진행.
- 자원 공유 효율
    - IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요없음.
    - 프로세스 안에 있으므로 프로세스의 데이터를 모두 접근 가능.
- 작업이 분리되어 코드가 간결
    - 사실 작성하기 나름.
    

<br>

## 쓰레드 단점
- 스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받음
    
- 쓰레드를 많이 생성하면 컨텍스트 스위칭이 많이 일어나 성능 저하.
    - ex) 리눅스 OS에서는 쓰레드를 프로세스와 같이 다룸
        - 쓰레드를 많이 생성하면 모든 스레드를 스케쥴링 해야 하므로 컨텍스트 스위칭이 빈번할 수 밖에 없음.
        

<br>

## 쓰레드 VS 프로세스
- 프로세스는 독립적, 스레드는 프로세스의 서브셋
- 프로세스는 각각 독립적인 자원을 가짐, 스레드는 프로세스 자원 공유
- 프로세스는 자신만의 주소영역을 가짐, 스레드는 주소영역 공유
- 프로세스간에는 IPC 기법으로 통신해야 함, 스레드는 필요 없음.

<br>

## PThread
- POSIX 스레드(POSIX Thread → 약어 PThread)
    - Thread 관련 표준 API


<br><br>


## 쓰레드 동기화(Synchronization) 이슈
- 동기화 : 작업들 사이에 실행시기를 맞추는 것
- 여러 스레드가 동일한 자원(데이터) 접근 시 동기화 이슈 발생
    - 동일 자원을 여러 스레드가 동시 수정 시, 각 스레드 결과에 영향을 줌.
    

<br>

## 동기화 이슈 해결 방안
- Mutual exclusion(상호 배제)
- 쓰레드는 프로세스 모든 데이터를 접근할 수 있으므로
    - 여러 쓰레드가 **변경**하는 공유 변수에 대해 exclussive access 필요
    - 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막아라.

<br>

## Mutual exclusion(상호배제)

- 임계자원(critical resource)
- 임계영역(critical section)

```python
lock.acquire()
for i in range(100000):
	g_count += 1
lock.release()

# for 문 : 임계영역
# g_count : 임계자원
```

<br>

## Mutex와 세마포어(Semaphore)

- Critical Section(임계 구역)에 대한 접근을 막기 위해 LOCKING 메커니즘이 필요
    - **Mutex**(binary semaphore)
        - 임계 영역에 **하나의 스레드**만 들어갈 수 있음.
    - **Semaphore**
        - 임계 구역에 **여러 스레드**가 들어갈 수 있음
        - **counter**를 두어 동시에 리소스에 접근할 수 있는 허용 가능한 스레드 수를 제어


<br>

## Semaphore

- P: 검사(임계영역에 들어갈때) - lock.acquire()
    - S 값이 1이상이면, 임계 영역 진입 후 S값 1차감(S값이 0이면 대기)
- V: 증가(임계영역에서 나올때) - lock.release()
    - S 값을 1더하고, 임계영역을 나옴
- S: 세마포어 값(초기 값만큼 여러 프로세스가 동시 임계 영역 접근가능) - S 개의 쓰레드가 임계영역 접근가능

```c
P(S): wait(S) {
	while S <= 0 // 대기
	;
	S--;   // 다른 프로세스 접근 제한
}
```

```c
V(S): signal(S) {
	S++;
}
```

세마포어(semaphore) - 바쁜 대기

- wait()은 S가 0이라면, 임계영역에 들어가기 위해 반복문 수행
    - 바쁜 대기(busy waiting)
    - 반복문을 돌기 때문에 CPU를 계속 실행시켜야함.
    

세마포어 - 대기큐

- 운영체제 기술로 보완 - 대기큐
- S가 음수일 경우, 바쁜 대기 대신, 대기큐에 넣는다

```c
wait(S) {
	S->count--;
	if (S->count < 0) {
		add this process to S->queue;
		block()
	}
}

signal(S) {
	S->count++;
	if (S->count < 0) {
		remove a process P from S->queue;
		wakeup(P)
	}
}
// wakeup()함수를 통해 대기큐에 있는 프로세스 재실행
```

- wait(s)에서는 이전 구현과 달리 s→count를 먼저 감소시키고 만약 이 감소가 s→count를 0미만으로 만들면(즉, 현재 스레드가 wait을 호출하였지만 세마포어에 빈자리가 없는 상태였다면) 현재 스레드를 block해서 기다리게 만듦.
- 이후에 세마포어를 먼저 획득한 스레드가 signal(s)를 불러 접근 허용 스레드를 하나 증가시키면(s→count ++) 다음 두가지 상황 중 하나가 됨.
    1. 기다리던 스레드가 없었고(증가 이전에 s→count가 0 또는 그 이상) 이제 하나의 스레드가 더 접근할 수 있는 경우 (s →count가 1또는 그 이상)
        - 기다리던 쓰레드가 없었고 증가 이후에 wait을 호출하는 스레드들은 s→countr를 감소시키며 block없이 진행할 수 있으므로 signal(s)에서 wakeup을 호출할 필요가 없음.
    2. 기다리던 스레드가 있었고(증가 이전에 s→count가 -1또는 그 이하), 이제 하나의 스레드가 더 접근할 수 있는 경우(s→count가 0또는 그 이하)
        - 기다리던 쓰레드가 있었고 s→count의 증가 이후에도 wait(s)를 호출하는 함수들은 다시 s→count를 음스로 만들면서 block할 예정이므로 signal(s)에서 wakeup을 통해 기다리던 스레드를 깨워주어야 함.
        

<br>

### 참고: 주요 세마포어 함수(POSIX 세마포어)

- sem_open() : 세마포어를 생성
- sem_wait() : 임계영역 접근 전, 세마포어를 잠그고 세마포어가 잠겨있따면 풀릴 때까지 대기
- sem_post() : 공유자원에 대한 접근이 끝났을 때 세마포어 잠금을 해제한다.


<br>

## 교착상태(Deadlock)

- 무한 대기 상태
    - 두개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에, 다음 단계로 진행하지 못하는 상태
        
    - 배치 처리 시스템에서는 일어나지 않는 문제. 프로세스, 스레드 둘 다 이와 같은 상태가 일어날 수 있음.
    
    ```python
    #Thread A
    
    lock.acquire(a)
    	-> use a
    	-> lock.acquire(b)
    lock.release(a)
    
    #Thread B
    lock.acquire(b)
    	-> use b
    	-> lock.acquire(a)
    lock.release(b)
    ```
    

참고: 교착상태 발생 조건

- 다음 네가지 조건이 모두 성립할 때 교착상태 발생 가능성이 있음.
    - **상호배제**(Mutual exclusion): 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
    - **점유대기**(Hold and wait) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
    - **비선점**(No preemption) : 프로세스가 어떤 자원의 사용을 끝낼때까지 그 자원을 뺏을 수 없다.
    - **순환대기**(Circular wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.

참고: 교착상태 해결 방법

- 위 네가지 조건 중 일부를 해소함.
    - 교착상태 예방, 회피, 발견, 회복

참고: 교창상태 발견(deadlock detection)과 회복

- 교착상태 발견(deadlock detection)
    - 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것.
- 교착상태 회복(deadlock recovery)
    - 교착상태를 일으키는 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것

<br>

## 기아상태(starvation)

- 특정 프로세스의 **우선순위**가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태
- 교착상태와 기아상태
    - 교착상태는 여러 프로세스가 동일 자원 점유를 요청할 때 발생
    - 기아상태는 여러 프로세스가 **부족한 자원**을 점유하기 위해 경쟁할 때 특정 프로세스는 영원히 자원할당이 안되는 경우를 주로 의미


<br>

## 기아상태 해결 방안

- 우선순위 변경
    - 프로세스 우선순위를 수시로 변경해서 각 프로세스가 높은 우선순위를 가질 기회 주기
    - 오래 기다린 프로세스의 우선순위 높여주기
    - 우선순위가 아닌 요청 순서대로 처리하는 FIFO 기반 요청큐 사용