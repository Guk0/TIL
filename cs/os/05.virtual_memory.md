# Virtual Memory
## 가상메모리(virtual memory system)

- 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음.
    - ex) 리눅스는 하나의 프로세스가 4GB임
    - 통상 메모리는  8GB, 16GB
    - 폰노이만 구조 기반이므로 코드는 메모리에 반드시 있어야 함.
                
- 프로세스가 특정시간에 참조하는 메모리는 제한적임. 현재 사용하는 공간만 메모리에 넣어줌.
- CPU가 특정 프로세스의 공간을 참조할때는 해당하는 물리 메모리 공간에 데이터가 어디있는지 알기만하면 됨.

<br>


## 가상메모리가 필요한 이유
- 하나의 프로세스만 실행가능한 시스템(배치처리 시스템)
    - 프로그램을 메모리에 로드(load)
    - 프로세스 실행
    - 프로세스 종료(메모리 해제)
    - 메모리가 부족하지 않음.
- 여러 프로세스 동시 실행 시스템
    - 메모리 용량 부족 이슈
    - 프로세스 메모리 영역간의 침범 이슈


<br>

## 가상메모리

- 메모리가 실제 메모리보다 많아 보이게하는 기술
    - 실제 사용하는 메모리는 작다는 점을 착안해서 고안된 기술
    - 프로세스간 공간 분리로 프로세스 이슈가 전체 시스템에 영향을 주지 않을  수 있음.
- 가상 메모리 기본 아이디어
    - 프로세스는 가상 주소를 사용하고 실제 해당 주소에서 데이터를 읽고 쓸때만 물리주소로 바꿔주면 된다
    - virtual address(가상주소): **프로세스가 참조하는 주소**
    - physical address(물리주소) : 실제 메모리 주소
- MMU(Memory Management Unit)
    - CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, **해당 주소를 물리 주소 값으로 변환해**주는 하드웨어 장치


<br>

## 가상메모리와 MMU

- CPU는 가상메모리를 다루고 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근
    - 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둠
        
        
<br>


## 페이징 시스템(paging system)

- 페이징 개념
    - **크기가 동일한 페이지**로 **가상주소 공간과 이에 매칭하는 물리 주소 공간을 관리**
    - 하드웨어 지원이 필요
        - ex) intel x86 시스템(32bit)에서 4KB, 2MB, 1GB지원
    - 리눅스에서 4KB로 paging
    - 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용
- 프로세스(4GB)의 PCB에 Page Table 구조체를 가리키는 주소가 들어있음.
- **Page Table**에는 가상 주소와 물리 주소간 매핑 정보가 있음.
    
<br>


## 페이징 시스템 구조

- page 또는 page frame은 고정된 크기의 block(4KB)
- paging system
    - 가상 주소 v = (p, d)
        - p : 가상 메모리 페이지
        - d : p안에서 참조하는 위치(변위)
            
    - ~~페이지 번호P 가상주소에 대한 물리주소를 기록해놓으면 가상주소에 변위를 더하면 실제 물리 메모리에 있는 해당 데이터의 위치를 알 수 있음.~~
- 페이지 크기가 4KB 예
    - 가상 주소의 0비트에서 11비트가 변위(d)를 나타내고
    - 12비트 이상이 페이지 번호가 될 수 있음.

<br>


## 페이지 테이블(page table)
- page table
    - **물리주소에 있는 페이지 번호**와 **해당 페이지의 첫 물리 주소 정보**를 **매핑**한 표
    - 가상주소 v  = (p, d)라면
        - p : **페이지 번호**
        - d : **페이지 처음부터 얼마 떨어진 위치**인지
- 페이징 시스템 동작
    - 해당 프로세스에서 특정 가상 주소에 엑세스를 하려면
        - 해당 프로세스의 Page table에 해당 가상 주소가 포함된 page 번호가 있는지 확인
        - page 번호가 있으면 이 Page에 매핑된 첫 물리 주소를 알아내고(p`)
        - p` + d가 실제 물리주소가 됨.
        
    - page3-2 : 2가 변위값.
    - page table에서 page3을 찾고 변위값 2를 더해서 page3-2의 실제 물리 메모리 주소를 알아낼 수 있음.
    - 페이지 테이블에는 페이지 번호, 가상주소, 물리주소 외에도 valid-invalid bit 정보를 가지고 있다. 해당 페이지가 현재 물리 메모리에 올라가 있는지 아닌지를 판단.


<br>

## 페이징 시스템과 MMU(컴퓨터 구조)

- CPU는 가상주소 접근시
    - MMU 하드웨어 장치를 통해 물리 메모리 접근
- 프로세스 생성시, 페이지 테이블 정보 생성
    - PCB 등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재
    - 프로세스 구동 시 해당 **페이지 테이블 base주소**가 별도 레지스터에 저장(**CR3**)
    - CPU가 가상 주소 접근 시, MMU가 페이지 테이블 base 주소를 접근하여 물리 주소를 가져옴.
    
<br>


## 다중 단계 페이징 시스템(계층적 페이지)

[https://inuplace.tistory.com/352](https://inuplace.tistory.com/352)

- 32bit 시스템에서 4kb 페이지를 위한 페이징 시스템은
    - 하위 12bit는 오프셋
    - 상위 20bit가 페이징 번호이므로, 2의 20승(1048576)개의 페이지 정보가 필요함
- 페이징 정보를 **단계**를 나누어 생성
    - 큰 영역 별로 구분할 수 있는 페이지 디렉토리들을 만들고 해당 페이지 디렉토리 영역을 사용하지 않는다면 페이지 테이블 자체를 생성하지 않음.
    - **필요없는 페이지는 생성하지 않으므로** **공간 절약** 가능.
- 페이지 번호를 나타내는 bit를 구분하여 단계를 나눔(리눅스는 3단계, 최근 4단계)

<br>


## MMU와 TLB

- MMU가 물리주소를 확인하기 위해 메모리를 갔다와야 함.
    - 메모리에 왔다갔다하는 시간도 꽤 크다.
- **TLB**(Translation Lookaside Buffer) : 페이지 정보 캐쉬  
    - TLB에 해당하는 물리주소가 있으면 2~4 단계를 거치지 않음.
    
<br>

## 페이징 시스템과 공유 메모리

- 프로세스간 동일한 물리 주소를 가리킬 수 있음(공간 절약, 메모리 할당 시간 절약)    
    - 프로세스 a와 b가 별도로 있고 fork된 상태.
    - 주황색 공간이 공유되고 있다고 가정.
    - 이 공유되는 공간만 물리 메모리에 올려놓음
- 물리 주소 데이터 변경시
    - 물리 주소에 데이터 수정 시도시 물리 주소를 복사할 수 있음(copy on write)
    
<br>


## 요구 페이징(Demand Paging 또는 Demanded Paging)

- 어느 시점에 페이지 블럭을 물리 메모리에 올려놔야 하는지에 관한 내용.
- 프로세스의 모든 데이터를 메모리로 적재하지 않고 **실행 중 필요한 시점에서만 메모리로 적재**함
    - 선행 페이징(anticipatory paging 또는 prepaging)의 반대 개념
        - 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념
    - 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장**(페이지 교체 알고리즘 필요)**
    
<br>


## 페이지 폴트(page fault)

- 인터럽트
- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
- 운영체제가 page fault가 일어나면 **해당 페이지를 물리 메모리에 올림**

<br>


### 생각해보기

- 페이지 폴트가 자주 일어나면?
    - 실행되기 전에 해당 페이지를 물리 메모리에 올려야 함.
        - 시간이 오래걸림.
- 페이지 폴트가 안 일어나게 하려면?
    - 향후 실행/참조될 코드/데이터를 미리 물리 메모리에 올리면 됨
        - 앞으로 있을 일을 예측해야 함 - 신의 영역
        
<br>

## 페이지 교체 정책(page replacement policy)

- 운영체제가 특정 페이지를 물리메모리에 올리려하는데 물리메모리가 다 차있다면?
    - 기존 페이지 중 하나를 물리메모리에서 저장매체로 내리고(저장)
    - 새로운 페이지를 해당 물리메모리 공간에 올린다.

<br>


### 페이지 교체 알고리즘(FIFO)

- FIFO Page Replacement Algorithm
    - 가장 먼저 들어온 페이지를 내리자.


<br>

### OPT(Optimal Replacement Algorithm)

- 최적 페이지 교체 알고리즘
    - **앞으로 가장 오랫동안 사용하지 않을 페이지**를 내리자
    - 일반 OS에서는 구현 불가.

<br>

### LRU(Least Recently Used)
- **가장 오래전에 사용된 페이지**를 교체
- OPT 교체 알고리즘이 구현 불가능하므로 과거 기록을 기반으로 시도

<br>

### LFU(Least Frequently Used)
- **가장 적게 사용된 페이지**를 내리자.

<br>

### NUR(Not Used Recently)
- LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법
- 각 페이지마다 참조 비트(R), 수정 비트(M)을 둠(R, M)
    - (0, 0), (0, 1), (1, 0), (1, 1) 순으로 페이지 교체.
    - 읽거나 쓰거나 할때 비트가 바뀜. (읽기, 쓰기)


<br><br>


## 쓰레싱(Thrashing)
- **반복적으로 페이지 폴트**가 발생하여 과도하게 페이지 교체 작입이 일어나 **실제로는 아무일도 하지 못하는 상황**


<br>

## 세그멘테이션 기법
- 페이징 기법과 비교
- 가상 메모리를 서로 다른 크기가 다른 논리적 단위인 **세그먼트**(Segment)로 분할
    - 페이징 기법에서는 가상 메모리를 같은 크기의 블록으로 분할
    - 예: x86 리얼모드
        - CS(Code Segment), DS(Data Segment), SS(Stack Segment), ES(Extra Segment)로 세그먼트를 나누어 메모리 접근

- 세그먼트 가상주소
    - v = (s, d) : s는 세그먼트 번호, d는 블록 내 세그먼트의 변위
        
- 세그멘테이션은 크기가 다른 segment 단위로 물리 메모리에 로딩    
- 페이징은 일정크기의 블럭으로 구분한다면 세그멘테이션은 할당되는 만큼 나눈다.

### 참고
- 내부 단편화(페이지 기법)
    - 페이지 블록만큼 데이터가 딱 맞게 채워져있지 않을 때 공간 낭비
- 외부 단편화(세그멘테이션 기법)
    - 물리 메모리가 원하는 **연속된 크기의 메모리를 제공해주지 못하는 경우**
- 세그멘테이션/페이징 모두 하드웨어 지원 필요
    - 다양한 컴퓨터 시스템에 이식성을 중요시하는 리눅스는 페이징 기법을 기반으로 구현

<br><br>


## 총정리
- 실행 파일이 1KB여도 가상메모리 영역에서는 4GB를 차지함.
- 가상메모리 영역은 페이징되어 나눠져있고 페이지 테이블에 실제 물리메모리에 올려져 있는 가상 메모리 페이지들에 대한 물리 메모리 주소들이 있음.
- 커널도 페이징되어 있음.
- 커널 영역은 프로세스 마다 공유되기 때문에 커널 영역의 물리 메모리 주소도 전부 같음. 즉, 페이지 테이블에 같은 물리 메모리 주소가 공유됨.
- lazy allocation(최대한 할당 지연)
  - 실행파일은 저장매체(hdd/sdd)에 존재.
  - 실행파일이 가상메모리화돼서 프로세스가 만들어진 뒤 실행되기 전까지는 어느 데이터도 물리메모리에 넣지 않음.
  - 실행되면 물리메모리에 올릴텐데 이 메커니즘이 요구 페이징.
  - 요구 페이징 → 페이지 폴트 발생. 페이지 폴트 발생하면 물리메모리에 올라가고 해당 페이지 테이블이 업데이트 됨.