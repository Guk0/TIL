# Overview
## 도커를 사용하는 이유?
서버, 패키지 버전, 운영체제 등등에 따라 프로그램을 설치하는 과정 중에 많은 에러가 발생하게 되고 설치할 때마다 커맨드를 입력하는 등 번거로운 부분이 많음.

세팅할 환경이 다르다면 또 다른 configuration 필요

→ 직접 커맨드를 입력하면서 세팅하는 것과 도커로 세팅하는 것의 차이

- 기존
    - wget ....~~~~
    - ....
    - ....
- 도커
    - `docker run -it redis`
    
<br>

## 도커란?

**컨테이너**를 사용하여 응용프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구이며 **컨테이너** 기반의 오픈소스 가상화 플랫폼이며 생태계.

<br>

## 컨테이너

컨테이너 안에 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해줌. 일반 컨테이너의 개념에서 물건을 손쉽게 운송해주는 것 처럼 프로그램을 손쉡게 이동 배포 관리를 할 수 있게 해줌. AWS, Azure, Google Cloud 등 어디에서든 실행 가능하게 해줌.

컨테이너는 코드와 모든 종속성을 패키지화하여 응용 프로그램이 한 컴퓨터 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 하는 소프트웨어의 표준 단위.

단순히 간단하고 편리하게 프로그램을 실행 시켜주는 것으로 정의하기도 함.

<br>

## 컨테이너 이미지

코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용 프로그램을 실행하는 데 필요한 모든 것을 포함하는 가볍고 독립적이며 실행 가능한 소프트웨어 패키지.

또한, 컨테이너 이미지는 런타임에 컨테이너가 되고 도커 컨테이너의 경우 도커 엔진에서 실행될 때 이미지가 컨테이너가 된다. 리눅스와 윈도우 기반 애플리케이션 모두에서 사용할 수 있는 컨테이너화된 소프트웨어는 인프라에 관계없이 항상 동일하게 실행됩니다. 컨테이너는 소프트웨어를 환경으로부터 격리시키고 개발과 스테이징의 차이에도 불구하고 균일하게 작동하도록 보장한다.
    

<br>

## 도커 cli

`docker run hello-world`

1. 도커 클라이언트에 커맨드를 입력하니 클라이언트에서 도커 서버로 요청을 보냄.
2. 서버에서 hello-world라는 이미지가 이미 로컬에 cache가 되어 있는지 확인.
3. 현재는 없기에 Unable to find image ~라는 문구가 2번째 줄에 표시
4. 그러면 Docker Hub라는 이미지가 저장되어 있는 곳에 가서 그 이미지를 가져오고  로컬에 Cache로 보관
5. 그 후 이제는 이미지가 있으니 그 이미지를 이용하여 컨테이너를 생성한다.
6. 그리고 이미지로 생성된 컨테이너는 이미지에서 받은 설정이나 조건에 따라 프로그램을 실행한다.


<br>

## 도커와 기존 가상화 기술과의 차이를 통한 컨테이너의 이해

- 가상화 기술이 나오기 전
    - 한대의 서버를 하나의 용도로만 사용
    - 남는 서버 공간 그대로 방치
    - 하나의 서버에 하나의 운영체제, 하나의 프로그램만을 운영.
    - 안정적이나 비효율 적이다
- 하이퍼 바이저 기반의 가상화 출현
    - 논리적으로 공간을 분할하여 VM이라는 독립적인 가상 환경의 서버 이용 가능
    - 하이퍼 바이저는 호스트 시스템에서 다수의 게스트 OS를 구동할 수 있게 하는 소프트웨어.
    - 하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링하는 중간 관리자.


<br>

## 하이퍼 바이저의 종류

- 네이티브 하이퍼 바이저
    - 하이퍼 바이저가 하드웨어를 직접 제어하기에 자원 효율적으로 사용 가능하며, 별도의 호스트 OS가 없으므로 오버헤드가 적다.
    - 하지만 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어렵다.
        
- 호스트형 하이퍼 바이저
    - 일반적인 소프트웨어처럼 호스트 OS 위에서 실행되며 하드웨어 자원을 VM 내부의 게스트OS에 에뮬레이트 하는 방식으로 오버헤드가 크다.
    - 하지만 게스트 OS 종류에 대한 제약이 없고 구현이 다소 쉽다.
    - 일반적으로 가장 많이 이용하는 방법.
      
- 격리 구조이기 떄문에 어느쪽에 에러가 생겨도 영향을 받지 않는다.

<br>

## 도커와 기존 가상화 기술의 차이

- VM과 비교하였을때 컨테이너는 하이퍼바이저와 게스트 OS가 필요하지 않아 더 가볍다.
- 어플리케이션을 실행할 때는 컨테이너 방식에서는 호스트 OS 위에 어플리케이션의 실행 패키지인 이미지를 배포하기만 하면됩.
- VM은 어플리케이션을 실행하기 위해서 VM을 띄우고 자원을 할당한 다음, 게스트 OS를 부팅하여 어플리케이션을 실행해야 해서 훨씬 복잡하고 무겁게 실행해야 함.
  
<br>

## 차이
- 도커 컨테이너
    - 도커 컨테이너에서 돌아가는 애플리케이션은 컨테이너가 제공하는 격리 기능 내부에 샌드박스가 있지만 여전히 같은 호스트의 다른 컨테이너와 동일한 커널을 공유한다.
    - 결과적으로 컨테이너 내부에서 실행되는 프로세스는 호스트 시스템(모든 프로세스를 나열할 수 있는 충분한 권한있음)에서 볼 수 있다.
    - 예를들어, 도커와 함께 몽고DB 컨테이너를 시작하면 호스트(도커x)의 일반 쉘에 ps-e grep 몽고를 실행하면 프로세스가 표시된다.
    - 또한 컨테이너가 전체 OS를 내장할 필요가 없는 결과, 그것들은 매우 가볍고, 일반적으로 약 5-100MB이다.
    
- 가상머신
    - 가상머신과 함께 VM 내부에서 실행되는 모든 것은 호스트 운영체제 또는 하이퍼바이저와 독립되어있다.
    - 가상 머신 플렛폼은 특정 VM에 대한 가상화 프로세스를 관리하기 위해 프로세스를 시작하고 호스트 시스템은 그것의 하드웨어 자원의 일부를 위해 새롭고 이 특정 VM만을 위한 커널을 부팅하고 (흔히 다소 큰) 운영 체제 프로세스 세트를 시작한다는 것이다.
    - 이것은 응용 프로그램만 포함하는 일반적인 컨테이너보다 VM의 크기를 훨씬 크게 만든다.
    - OS까지 가상화... 맥에서 윈도우를 설치한다든지 리눅스에서 윈도우를 설치한다든지..
    - 이러한 방법은 비교적 간단하게 사용할 수 있지만 굉장히 느리다.
    
<br>

## 컨테이너 격리 방법

- 리눅스에서 사용하는 Cgroup(control groups)과 네임스페이스(namespaces)에 대해 알아야 합니다.
- 이것들은 컨테이너와 호스트에서 실행되는 다른 프로세스 사이에 벽을 만드는 리눅스 커널 기능들입니다.
- C Group
    - CPU, 메모리, Network Bandwith, HD i/o 등 프로세스 그룹의 시스템 리소스 사용량을 관리
    - 어떤 어플리케이션이 사용량이 너무 많다면 그 어플리케이션 같은 것을 C group에 넣어 CPU와 메모리 사용 제한 가능.
- 네임스페이스
    - 하나의 시스템에서 프로세스를 격리싴리 수  있는 가상화 기술.
    - 별개의 독립된 공간을 사용하는 것처럼 격리된 환경을 제공하는 경량 프로세스 가상화 기술.
    